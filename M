LBL M
GTO M009
GTO M017
GTO M034
GTO M089
GTO M148
GTO M230
MATSTOR
XEQ M028
STO(J)
R⬇
ISG J
GTO M010
R⬇
RTN
MATRCL
XEQ M028
RCL(J)
ISG J
GTO M018
x<>y
R⬇
x<>y
R⬆
x<>y
RTN
INIT
x<> J
CLx
130.132
x<> J
RTN
MAT-VEC
XEQ S001
XEQ M028
ENTER
ENTER
RCL×(J)
R⬇
ISG J
GTO M038
CLx
[REGT,REGZ,REGY]
STO(J)
XEQ S011
CLx
133
STO J
CLx
RCL(J)
RTN
MATSTOR2
XEQ M056
GTO M010
INIT2
x<> J
CLx
134.136
x<> J
RTN
TRANS2
GTO M071
XEQ M056
RCL(I)
RCL(J)
×
ISG J
GTO M064
[REGX,REGY,REGZ]
RTN
137.139
STO I
[1,0,0]
STO(I)
XEQ M063
STO(I)
ISG I
[0,1,0]
STO(I)
XEQ M063
STO(I)
ISG I
[0,0,1]
STO(I)
XEQ M063
STO(I)
RTN
MAT-MAT
XEQ M053
XEQ M062
XEQ M028
137.139
STO I
RCL(J)
RCL×(I)
ISG I
GTO M094
[REGZ,REGY,REGX]
RCL J
4
+
STO I
R⬇
STO(I)
ISG J
GTO M092
XEQ M113
R⬆
CLx
R⬇
RTN
MATRCL2
XEQ M056
GTO M018
XTRACT
1
-
STO I
3
STO÷ I
RMDR
130
STO+ I
CLx
137.139
STO J
CLx
[1,0,0]
STO(J)
ISG J
CLx
[0,1,0]
STO(J)
ISG J
CLx
[0,0,1]
STO(J)
CLx
137
+
STO J
CLx
RCL(J)
RCL(I)
×
RTN
DETER
7
XEQ M116
5
XEQ M116
3
XEQ M116
×
×
136
STO J
R⬇
STO(J)
1
XEQ M116
6
XEQ M116
8
XEQ M116
×
×
136
STO J
R⬇
STO+(J)
2
XEQ M116
4
XEQ M116
9
XEQ M116
×
×
136
STO J
R⬇
STO+(J)
7
XEQ M116
6
XEQ M116
2
XEQ M116
×
×
136
STO J
R⬇
STO-(J)
5
XEQ M116
9
XEQ M116
1
XEQ M116
×
×
136
STO J
R⬇
STO-(J)
8
XEQ M116
3
XEQ M116
4
XEQ M116
×
×
136
STO J
R⬇
STO-(J)
CLSTK
RCL(J)
RTN
STOR+135
135
STO J
R⬇
STO+(J)
RTN
EIGEN
XEQ M148
134
STO J
R⬇
STO(J)
7
XEQ M116
5
XEQ M116
×
+/-
135
STO J
R⬇
STO(J)
7
XEQ M116
3
XEQ M116
×
+/-
XEQ M224
5
XEQ M116
3
XEQ M116
×
+/-
XEQ M224
6
XEQ M116
2
XEQ M116
×
XEQ M224
9
XEQ M116
1
XEQ M116
×
XEQ M224
4
XEQ M116
8
XEQ M116
×
XEQ M224
7
XEQ M116
5
XEQ M116
3
XEQ M116
+
+
-1
x<>y
135
STO J
CLx
RCL(J)
134
STO J
CLx
RCL(J)
XEQ C001
RTN

CK=EF33
LN=1174

Routine MATRIX. Contains several 3×3 matrix subroutines. HP-35s supports
single-variable vector storage with limited operations on these vectors and
this is used to represent a matrix by three vectors at the bottom of the stack.
One matrix may be stored and recalled by public routines. For a more advanced
(but cumbersome) routine for N-dimensional matrices, see [Stefan Vorkoetter's
code](http://www.stefanv.com/calculators/hp35s_matrix_multitool.html "HP-35s
Matrix Multitool").

Public subroutines:
M002 MATSTOR stores a matrix represented by three vectors in stack registers
                REGZ, REGY and REGX.
M003 MATRCL recalls the stored matrix back to the stack.
M004 MAT-VEC multiplies the vector in REGX with the previously stored matrix.
M005 MAT-MAT multiplies the matrix on the stack with the previously stored
                matrix.
M006 DETER computes the determinant of the previously stored matrix.
M007 EIGEN computes the three eigenvalues of the previously stored matrix.

Uses memory: I, J
Uses routines: S, C

Private subroutines:
INIT initilizes J for addresses 130-132.
MATSTOR2 stores a matrix from the stack into addresses 134-136.
INIT2 initializes J for addresses 134-136.
TRANS2 transposes the matrix stored in 134-136 into 137-139.
MATRCL2 restores the matrix stored by MATSTOR2.
XTRACT given a component number from 1 to 9, returns the requested compontent of
        the stored matrix.
STOR+135 does a STO+(J) for J=135, used in EIGEN.

Example: to calculate the matrix-vector product

    [ 1 2 3 ] [ 1 ]   [ 14 ]
    [ 4 5 6 ] [ 2 ] = [ 32 ]
    [ 7 8 9 ] [ 3 ]   [ 50 ]

type in

  [1,2,3]
  ENTER
  [4,5,6]
  ENTER
  [7,8,9]
  ENTER
  [1,2,3]
  XEQ M006

which yields

  [14,32,50]


Example: to calculate the matrix-matrix product

    [ 1 2 3 ] [ 1   2   3   ]   [ 321 642  963  ]
    [ 4 5 6 ] [ 10  20  30  ] = [ 654 1308 1962 ]
    [ 7 8 9 ] [ 100 200 300 ]   [ 987 1974 2961 ]

type in

  [1,2,3]
  ENTER
  [4,5,6]
  ENTER
  [7,8,9]
  XEQ M002
  [1,2,3]
  ENTER
  [10,20,30]
  ENTER
  [100,200,300]
  XEQ M005

which yields

  0
  [321,642,963]
  [654,1308,1962]
  [987,1974,2961]

where the top two values can be seen by rolling the stack.
